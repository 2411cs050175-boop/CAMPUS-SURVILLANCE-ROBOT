import RPi.GPIO as GPIO
from time import sleep, time
import threading

GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)

# === MOTOR DRIVER (Single L298N for 4 Wheels) ===
IN1, IN2, IN3, IN4 = 17, 27, 22, 23
ENA, ENB = 24, 25
from django.http import JsonResponse

motor_pins = [IN1, IN2, IN3, IN4, ENA, ENB]
for pin in motor_pins:
    GPIO.setup(pin, GPIO.OUT)

# PWM (Speed Control)
ena_pwm = GPIO.PWM(ENA, 1000)
enb_pwm = GPIO.PWM(ENB, 1000)
ena_pwm.start(100)
enb_pwm.start(100)

# === ULTRASONIC SENSORS ===
TRIG_FRONT, ECHO_FRONT = 16, 18
TRIG_BACK, ECHO_BACK = 12, 26

GPIO.setup(TRIG_FRONT, GPIO.OUT)
GPIO.setup(ECHO_FRONT, GPIO.IN)
GPIO.setup(TRIG_BACK, GPIO.OUT)
GPIO.setup(ECHO_BACK, GPIO.IN)

# === GLOBAL CONTROL FLAG ===
auto_mode = False  # For start/stop from frontend


# --- Helper functions ---
def get_distance(TRIG, ECHO):
    GPIO.output(TRIG, True)
    sleep(0.00001)
    GPIO.output(TRIG, False)

    start_time = time()
    stop_time = time()

    while GPIO.input(ECHO) == 0:
        start_time = time()
    while GPIO.input(ECHO) == 1:
        stop_time = time()

    elapsed = stop_time - start_time
    distance = (elapsed * 34300) / 2
    return round(distance, 2)


def move_forward():
    GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.HIGH)
    GPIO.output(IN4, GPIO.LOW)


def move_backward():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.HIGH)


def turn_left():
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN3, GPIO.HIGH)
    GPIO.output(IN4, GPIO.LOW)


def turn_right():
    GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.HIGH)


def stop_all():
    for pin in [IN1, IN2, IN3, IN4]:
        GPIO.output(pin, GPIO.LOW)


# === AUTOMATIC OBSTACLE AVOID LOOP ===
def auto_drive():
    global auto_mode
    auto_mode = True
    print("ðŸ¤– Auto drive started")

    try:
        while auto_mode:
            front_dist = get_distance(TRIG_FRONT, ECHO_FRONT)
            back_dist = get_distance(TRIG_BACK, ECHO_BACK)
            print(f"Front: {front_dist} cm | Back: {back_dist} cm")

            # If obstacle in front
            if front_dist < 25:
                print("ðŸš¨ Obstacle ahead! Moving backward")
                move_backward()

                # While going backward, check back distance
                while True:
                    if not auto_mode:
                        break
                    back_dist = get_distance(TRIG_BACK, ECHO_BACK)
                    print(f"â†©ï¸ Back Distance: {back_dist} cm")
                    if back_dist < 20:
                        print("ðŸ›‘ Object behind! Stopping")
                        stop_all()
                        sleep(1)
                        break
                    sleep(0.1)

            else:
                move_forward()

            sleep(0.2)

    except Exception as e:
        print("Error:", e)
        stop_all()


# === Django API ===
def control_robot(request):
    global auto_mode
    cmd = request.GET.get("cmd", "")
    speed = int(request.GET.get("speed", 100))

    ena_pwm.ChangeDutyCycle(speed)
    enb_pwm.ChangeDutyCycle(speed)

    if cmd == "forward":
        move_forward()
        action = "Moving forward"
    elif cmd == "backward":
        move_backward()
        action = "Moving backward"
    elif cmd == "left":
        turn_left()
        action = "Turning left"
    elif cmd == "right":
        turn_right()
        action = "Turning right"
    elif cmd == "stop":
        stop_all()
        auto_mode = False
        action = "Stopped"
    elif cmd == "start":  # start auto mode
        t = threading.Thread(target=auto_drive)
        t.start()
        action = "Auto obstacle mode started"
    else:
        action = "Invalid command"

    print(f"Executed: {action}")
    return JsonResponse({"action": action})
